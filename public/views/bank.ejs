<%- include('partials/header', { 
    title: 'Bank Account',
    pageTitle: 'üè¶ BANK ACCOUNT',
    pageStyles: `
        .account-summary {
            background-color: #000;
            border: 2px solid #00ff00;
            padding: 20px;
            margin-bottom: 20px;
        }
        .balance {
            font-size: 2em;
            text-align: center;
            margin: 20px 0;
            color: #00ff00;
        }
        .portfolio {
            background-color: #000;
            border: 2px solid #00ff00;
            padding: 20px;
            margin-bottom: 20px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #003300;
        }
        th {
            background-color: #003300;
        }
        .total-value {
            font-size: 1.5em;
            text-align: right;
            margin-top: 20px;
            padding: 10px;
            border-top: 2px solid #00ff00;
        }
        .quick-btn {
            background-color: #003300;
            color: #00ff00;
            border: 1px solid #00ff00;
            padding: 5px 10px;
            margin: 2px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
        }
        .quick-btn:hover {
            background-color: #00ff00;
            color: #000;
        }
        .quick-sell-btn {
            background-color: #330000;
            border-color: #ff0000;
            color: #ff0000;
        }
        .quick-sell-btn:hover {
            background-color: #ff0000;
            color: #000;
        }
    `
}) %>

        <div class="account-summary">
            <h2>Account Summary</h2>
            <div class="balance">
                Cash Balance: $<span id="cashBalance">0.00</span>
            </div>
            <div class="balance" style="font-size: 1em; margin: 10px 0;">
                Purchasing Power (1970 dollars): $<span id="realValue">0.00</span>
                <span style="cursor: help; color: #00aa00; margin-left: 8px;" title="This shows what your current cash would be worth in 1970 dollars, adjusted for inflation. Your starting $10,000 in 1970 would be worth much more in today's dollars!">‚ÑπÔ∏è</span>
            </div>
            <div style="text-align: center; color: #00aa00; margin: 10px 0;">
                Inflation Rate: <span id="inflationRate">0</span>% | Cumulative: <span id="cumulativeInflation">1.0</span>x
            </div>
            <div style="text-align: center; color: #00ff00; margin: 10px 0; font-size: 1.2em;">
                Credit Score: <span id="creditScore">---</span>
            </div>
            <div id="wealthTaxInfo" style="text-align: center; color: #ffaa00; margin: 10px 0; padding: 10px; border: 1px solid #664400; background-color: #221100; display: none;">
                <strong>‚ö†Ô∏è Wealth Tax Notice:</strong><br>
                Net Worth: $<span id="netWorth">0</span> | Next Annual Tax: $<span id="estimatedWealthTax">0</span>
                <span style="cursor: help; color: #ffaa00; margin-left: 8px;" title="You pay 1% annual wealth tax on net worth exceeding $50,000. This is assessed automatically each year.">‚ÑπÔ∏è</span>
            </div>
        </div>
        
        <div class="account-summary" id="marginSection" style="display: none;">
            <h2>üí∞ Margin Account</h2>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 15px;">
                <div>
                    <div style="font-size: 0.9em; color: #00aa00;">Margin Balance (Borrowed):</div>
                    <div style="font-size: 1.5em; color: #ff8800; margin: 5px 0;">$<span id="marginBalance">0.00</span></div>
                </div>
                <div>
                    <div style="font-size: 0.9em; color: #00aa00;">Buying Power:</div>
                    <div style="font-size: 1.5em; color: #00ff00; margin: 5px 0;">$<span id="buyingPower">0.00</span></div>
                </div>
                <div>
                    <div style="font-size: 0.9em; color: #00aa00;">Current Leverage:</div>
                    <div style="font-size: 1.5em; margin: 5px 0;"><span id="currentLeverage">1.0</span>:1</div>
                </div>
                <div>
                    <div style="font-size: 0.9em; color: #00aa00;">Margin Ratio:</div>
                    <div style="font-size: 1.5em; margin: 5px 0;"><span id="marginRatio">100</span>%</div>
                </div>
            </div>
            <div id="marginCallWarning" style="display: none; background-color: #440000; border: 2px solid #ff0000; padding: 10px; margin-top: 15px; text-align: center; color: #ff0000; font-weight: bold;">
                ‚ö†Ô∏è MARGIN CALL: Deposit $<span id="marginCallAmount">0</span> or reduce positions
            </div>
        </div>
        
        <div class="portfolio">
            <h2>üìà Combined Portfolio (Stocks & Index Funds)</h2>
            <div style="margin-bottom: 15px; display: flex; gap: 10px; flex-wrap: wrap; align-items: center;">
                <button class="quick-sell-btn" onclick="sellAllPositions()" style="padding: 8px 16px; font-size: 1em;">
                    üî¥ Sell All Positions
                </button>
                <button class="quick-sell-btn" onclick="sellToZeroGains()" style="padding: 8px 16px; font-size: 1em;">
                    ‚öñÔ∏è Sell Losing Positions
                </button>
                <button class="quick-sell-btn" onclick="sellToZeroProfit()" style="padding: 8px 16px; font-size: 1em;">
                    ‚öñÔ∏è Sell Till Profit is 0
                </button>
                <button class="quick-sell-btn" onclick="sellSelectedPositions()" style="padding: 8px 16px; font-size: 1em;">
                    üìã Sell Selected
                </button>
                <label style="color: #00aa00; margin-left: 15px;">
                    <input type="checkbox" id="selectAllPositions" onchange="toggleAllPositions()"> Select All
                </label>
            </div>
            <table id="combinedPortfolioTable">
                <thead>
                    <tr>
                        <th style="width: 40px;">Select</th>
                        <th>Symbol</th>
                        <th>Type</th>
                        <th>Shares</th>
                        <th>Avg Cost</th>
                        <th>Current Price</th>
                        <th>Total Value</th>
                        <th>Total Cost</th>
                        <th>Gain/Loss</th>
                        <th>Return %</th>
                        <th>Quick Actions</th>
                    </tr>
                </thead>
                <tbody id="combinedPortfolioList">
                    <tr><td colspan="11">Loading...</td></tr>
                </tbody>
            </table>
            <div class="total-value">
                Total Invested: $<span id="totalCost">0.00</span>
            </div>
            <div class="total-value">
                Total Portfolio Value: $<span id="portfolioValue">0.00</span>
            </div>
            <div class="total-value" style="font-size: 1.5em;">
                Total Gain/Loss: <span id="totalGainLoss" class="positive">$0.00</span>
                (<span id="totalReturnPercent">0.00</span>%)
            </div>
            <div class="total-value">
                Total Account Value: $<span id="totalValue">0.00</span>
            </div>
        </div>
        
        <div class="portfolio" id="shortPositionsSection" style="display: none;">
            <h2>Short Positions</h2>
            <div style="margin-bottom: 15px;">
                <button class="quick-btn" onclick="coverAllShorts()" style="padding: 8px 16px; font-size: 1em;">
                    üîÑ Cover All Shorts
                </button>
            </div>
            <table>
                <thead>
                    <tr>
                        <th>Symbol</th>
                        <th>Shares</th>
                        <th>Borrow Price</th>
                        <th>Current Price</th>
                        <th>P&L</th>
                        <th>Quick Actions</th>
                    </tr>
                </thead>
                <tbody id="shortPositionsList">
                    <tr><td colspan="6">No short positions</td></tr>
                </tbody>
            </table>
        </div>
        
        <div class="portfolio">
            <h2>Recent Transactions</h2>
            <table id="transactionsTable">
                <thead>
                    <tr>
                        <th>Date</th>
                        <th>Type</th>
                        <th>Symbol</th>
                        <th>Shares</th>
                        <th>Price</th>
                        <th>Fee</th>
                        <th>Tax</th>
                        <th>Total</th>
                    </tr>
                </thead>
                <tbody id="transactionsList">
                    <tr><td colspan="8">No transactions</td></tr>
                </tbody>
            </table>
        </div>
        
        <div class="portfolio">
            <h2>Dividend History</h2>
            <table>
                <thead>
                    <tr>
                        <th>Date</th>
                        <th>Quarter</th>
                        <th>Gross</th>
                        <th>Tax</th>
                        <th>Net</th>
                    </tr>
                </thead>
                <tbody id="dividendsList">
                    <tr><td colspan="5">No dividends yet</td></tr>
                </tbody>
            </table>
        </div>
        
        <div class="portfolio">
            <h2>Fees & Costs</h2>
            <table>
                <thead>
                    <tr>
                        <th>Date</th>
                        <th>Type</th>
                        <th>Amount</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody id="feesList">
                    <tr><td colspan="4">No fees charged</td></tr>
                </tbody>
            </table>
        </div>

<%- include('partials/footer', {
    pageScripts: `
    <script src="table-sorter.js"></script>
    <script>
        let portfolioSorter, transactionsSorter;
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        async function updateAccount() {
            const [accountRes, stocksRes] = await Promise.all([
                fetch('/api/account'),
                fetch('/api/stocks')
            ]);
            
            const account = await accountRes.json();
            const stocks = await stocksRes.json();
            
            document.getElementById('cashBalance').textContent = account.cash.toFixed(2);
            
            // Update credit score
            if (account.creditScore) {
                document.getElementById('creditScore').textContent = account.creditScore;
            }
            
            // Update inflation data
            if (account.inflationData) {
                document.getElementById('realValue').textContent = account.inflationData.realValue.toFixed(2);
                document.getElementById('inflationRate').textContent = account.inflationData.currentRate.toFixed(1);
                document.getElementById('cumulativeInflation').textContent = account.inflationData.cumulativeInflation.toFixed(2);
            }
            
            // Build combined portfolio with extended information
            await updateCombinedPortfolio(account, stocks);
            
            // Display margin account information
            if (account.marginAccount && account.marginAccount.hasMarginEnabled) {
                const marginSection = document.getElementById('marginSection');
                marginSection.style.display = 'block';
                
                document.getElementById('marginBalance').textContent = account.marginAccount.marginBalance.toFixed(2);
                document.getElementById('buyingPower').textContent = account.marginAccount.buyingPower.toFixed(2);
                document.getElementById('currentLeverage').textContent = account.marginAccount.currentLeverage.toFixed(2);
                
                if (account.portfolioMetrics) {
                    document.getElementById('marginRatio').textContent = (account.portfolioMetrics.marginRatio * 100).toFixed(1);
                    
                    // Show margin call warning if applicable
                    if (account.portfolioMetrics.marginCallStatus && account.portfolioMetrics.marginCallStatus.isMarginCall) {
                        const marginCallWarning = document.getElementById('marginCallWarning');
                        marginCallWarning.style.display = 'block';
                        document.getElementById('marginCallAmount').textContent = account.portfolioMetrics.marginCallStatus.amountNeeded.toFixed(2);
                    } else {
                        document.getElementById('marginCallWarning').style.display = 'none';
                    }
                }
            }
            
            // Update short positions
            const shortPositionsSection = document.getElementById('shortPositionsSection');
            const shortPositionsList = document.getElementById('shortPositionsList');
            if (account.shortPositions && Object.keys(account.shortPositions).length > 0) {
                shortPositionsSection.style.display = 'block';
                shortPositionsList.innerHTML = Object.entries(account.shortPositions)
                    .filter(([_, position]) => position.shares > 0)
                    .map(([symbol, position]) => {
                        const stock = stocks.find(s => s.symbol === symbol);
                        const currentPrice = stock ? stock.price : 0;
                        const pnl = (position.borrowPrice - currentPrice) * position.shares;
                        const pnlClass = pnl >= 0 ? 'positive' : 'negative';
                        
                        return \`
                            <tr>
                                <td>\${symbol}</td>
                                <td>\${position.shares}</td>
                                <td>$\${position.borrowPrice.toFixed(2)}</td>
                                <td>$\${currentPrice.toFixed(2)}</td>
                                <td class="\${pnlClass}">$\${pnl.toFixed(2)}</td>
                                <td>
                                    <button class="quick-btn" onclick="coverShort('\${escapeHtml(symbol)}', \${position.shares})">Cover</button>
                                </td>
                            </tr>
                        \`;
                    }).join('');
            } else {
                shortPositionsSection.style.display = 'none';
            }
            
            // Update transactions list
            const transactionsList = document.getElementById('transactionsList');
            if (!account.transactions || account.transactions.length === 0) {
                transactionsList.innerHTML = '<tr><td colspan="8">No transactions</td></tr>';
            } else {
                transactionsList.innerHTML = account.transactions.slice().reverse().map(tx => \`
                    <tr>
                        <td>\${new Date(tx.date).toLocaleDateString()}</td>
                        <td>\${escapeHtml(tx.type.toUpperCase())}</td>
                        <td>\${escapeHtml(tx.symbol)}</td>
                        <td>\${tx.shares}</td>
                        <td>$\${tx.pricePerShare.toFixed(2)}</td>
                        <td>\${tx.tradingFee ? '$' + tx.tradingFee.toFixed(2) : '-'}</td>
                        <td>\${tx.tax ? '$' + tx.tax.toFixed(2) : '-'}</td>
                        <td>$\${(tx.netProceeds || tx.total).toFixed(2)}</td>
                    </tr>
                \`).join('');
                
                // Initialize or refresh sorter for transactions
                if (!transactionsSorter) {
                    transactionsSorter = makeSortable('transactionsTable');
                } else {
                    transactionsSorter.refresh();
                }
            }
            
            // Update dividends list
            const dividendsList = document.getElementById('dividendsList');
            if (!account.dividends || account.dividends.length === 0) {
                dividendsList.innerHTML = '<tr><td colspan="5">No dividends yet</td></tr>';
            } else {
                dividendsList.innerHTML = account.dividends.slice().reverse().map(div => \`
                    <tr>
                        <td>\${new Date(div.date).toLocaleDateString()}</td>
                        <td>\${escapeHtml(div.quarter)}</td>
                        <td>$\${div.grossAmount.toFixed(2)}</td>
                        <td>$\${div.tax.toFixed(2)}</td>
                        <td>$\${div.netAmount.toFixed(2)}</td>
                    </tr>
                \`).join('');
            }
            
            // Update fees list
            const feesList = document.getElementById('feesList');
            if (!account.fees || account.fees.length === 0) {
                feesList.innerHTML = '<tr><td colspan="4">No fees charged</td></tr>';
            } else {
                feesList.innerHTML = account.fees.slice().reverse().map(fee => \`
                    <tr>
                        <td>\${new Date(fee.date).toLocaleDateString()}</td>
                        <td>\${escapeHtml(fee.type)}</td>
                        <td>$\${fee.amount.toFixed(2)}</td>
                        <td>\${escapeHtml(fee.description)}</td>
                    </tr>
                \`).join('');
            }
        }
        
        // Update combined portfolio with extended information
        async function updateCombinedPortfolio(account, stocks) {
            const combinedList = document.getElementById('combinedPortfolioList');
            let totalPortfolioValue = 0;
            let totalCost = 0;
            const positions = [];
            
            // Save current checkbox states before re-rendering
            const checkedSymbols = new Set();
            document.querySelectorAll('.position-checkbox:checked').forEach(cb => {
                checkedSymbols.add(cb.dataset.symbol);
            });
            
            // Fetch index funds data
            const indexFundsRes = await fetch('/api/indexfunds');
            const indexFunds = await indexFundsRes.json();
            
            // Process stock positions
            for (const [symbol, shares] of Object.entries(account.portfolio)) {
                if (shares <= 0) continue;
                
                const stock = stocks.find(s => s.symbol === symbol);
                const currentPrice = stock ? stock.price : 0;
                const totalValue = shares * currentPrice;
                
                // Calculate average cost from purchase history
                let avgCost = 0;
                let positionCost = 0;
                if (account.purchaseHistory && account.purchaseHistory[symbol]) {
                    let totalShares = 0;
                    let totalPaid = 0;
                    account.purchaseHistory[symbol].forEach(purchase => {
                        totalShares += purchase.shares;
                        totalPaid += purchase.shares * purchase.pricePerShare;
                    });
                    if (totalShares > 0) {
                        avgCost = totalPaid / totalShares;
                        positionCost = shares * avgCost;
                    }
                }
                
                const gainLoss = totalValue - positionCost;
                const returnPercent = positionCost > 0 ? (gainLoss / positionCost) * 100 : 0;
                
                positions.push({
                    symbol,
                    type: 'üìà Stock',
                    shares,
                    avgCost,
                    currentPrice,
                    totalValue,
                    totalCost: positionCost,
                    gainLoss,
                    returnPercent
                });
                
                totalPortfolioValue += totalValue;
                totalCost += positionCost;
            }
            
            // Process index fund positions
            if (account.indexFundHoldings) {
                for (const [symbol, holding] of Object.entries(account.indexFundHoldings)) {
                    if (holding.shares <= 0) continue;
                    
                    const fund = indexFunds.find(f => f.symbol === symbol);
                    const currentPrice = fund ? fund.price : 0;
                    const totalValue = holding.shares * currentPrice;
                    
                    // Calculate average cost
                    let avgCost = 0;
                    let positionCost = 0;
                    if (holding.purchaseHistory && holding.purchaseHistory.length > 0) {
                        let totalShares = 0;
                        let totalPaid = 0;
                        holding.purchaseHistory.forEach(purchase => {
                            totalShares += purchase.shares;
                            totalPaid += purchase.shares * purchase.pricePerShare;
                        });
                        if (totalShares > 0) {
                            avgCost = totalPaid / totalShares;
                            positionCost = holding.shares * avgCost;
                        }
                    }
                    
                    const gainLoss = totalValue - positionCost;
                    const returnPercent = positionCost > 0 ? (gainLoss / positionCost) * 100 : 0;
                    
                    positions.push({
                        symbol,
                        type: 'üìä Index Fund',
                        shares: holding.shares,
                        avgCost,
                        currentPrice,
                        totalValue,
                        totalCost: positionCost,
                        gainLoss,
                        returnPercent
                    });
                    
                    totalPortfolioValue += totalValue;
                    totalCost += positionCost;
                }
            }
            
            // Render combined portfolio
            if (positions.length === 0) {
                combinedList.innerHTML = '<tr><td colspan="11">No positions</td></tr>';
            } else {
                combinedList.innerHTML = positions.map(pos => {
                    const gainLossClass = pos.gainLoss >= 0 ? 'positive' : 'negative';
                    const returnClass = pos.returnPercent >= 0 ? 'positive' : 'negative';
                    
                    // Determine the trade URL based on type
                    const isStock = pos.type.includes('Stock');
                    const tradeUrl = isStock ? '/trading' : '/indexfunds';
                    
                    return \`
                        <tr>
                            <td><input type="checkbox" class="position-checkbox" data-symbol="\${escapeHtml(pos.symbol)}" data-shares="\${pos.shares}" data-isstock="\${isStock}"></td>
                            <td><strong>\${pos.symbol}</strong></td>
                            <td>\${pos.type}</td>
                            <td>\${pos.shares.toFixed(2)}</td>
                            <td>$\${pos.avgCost.toFixed(2)}</td>
                            <td>$\${pos.currentPrice.toFixed(2)}</td>
                            <td>$\${pos.totalValue.toFixed(2)}</td>
                            <td>$\${pos.totalCost.toFixed(2)}</td>
                            <td class="\${gainLossClass}">$\${pos.gainLoss.toFixed(2)}</td>
                            <td class="\${returnClass}">\${pos.returnPercent.toFixed(2)}%</td>
                            <td>
                                <button class="quick-btn" onclick="quickBuy('\${escapeHtml(pos.symbol)}', \${isStock})">+Buy</button>
                                <button class="quick-btn quick-sell-btn" onclick="quickSell('\${escapeHtml(pos.symbol)}', \${pos.shares}, \${isStock})">Sell</button>
                            </td>
                        </tr>
                    \`;
                }).join('');
                
                // Restore checkbox states after rendering
                document.querySelectorAll('.position-checkbox').forEach(cb => {
                    if (checkedSymbols.has(cb.dataset.symbol)) {
                        cb.checked = true;
                    }
                });
                
                // Initialize or refresh sorter
                if (!portfolioSorter) {
                    portfolioSorter = makeSortable('combinedPortfolioTable', {
                        defaultSort: { column: 6, direction: 'desc' } // Sort by Total Value descending (adjusted for checkbox column)
                    });
                } else {
                    portfolioSorter.refresh();
                }
            }
            
            // Update totals
            document.getElementById('totalCost').textContent = totalCost.toFixed(2);
            document.getElementById('portfolioValue').textContent = totalPortfolioValue.toFixed(2);
            
            const totalGainLoss = totalPortfolioValue - totalCost;
            const totalReturn = totalCost > 0 ? (totalGainLoss / totalCost) * 100 : 0;
            
            const gainLossEl = document.getElementById('totalGainLoss');
            gainLossEl.textContent = '$' + totalGainLoss.toFixed(2);
            gainLossEl.className = totalGainLoss >= 0 ? 'positive' : 'negative';
            
            document.getElementById('totalReturnPercent').textContent = totalReturn.toFixed(2);
            const totalAccountValue = account.cash + totalPortfolioValue;
            document.getElementById('totalValue').textContent = totalAccountValue.toFixed(2);
            
            // Calculate and display wealth tax info
            const WEALTH_TAX_THRESHOLD = 50000;
            const WEALTH_TAX_RATE = 0.01;
            const netWorth = totalAccountValue - (account.marginAccount ? account.marginAccount.marginBalance : 0);
            
            if (netWorth > WEALTH_TAX_THRESHOLD) {
                const taxableWealth = netWorth - WEALTH_TAX_THRESHOLD;
                const estimatedTax = taxableWealth * WEALTH_TAX_RATE;
                
                document.getElementById('netWorth').textContent = netWorth.toFixed(2);
                document.getElementById('estimatedWealthTax').textContent = estimatedTax.toFixed(2);
                document.getElementById('wealthTaxInfo').style.display = 'block';
            } else {
                document.getElementById('wealthTaxInfo').style.display = 'none';
            }
        }
        
        // Quick trade functions
        async function quickBuy(symbol, isStock) {
            const shares = prompt(\`How many shares of \${symbol} would you like to buy?\`, '1');
            if (!shares || parseFloat(shares) <= 0) return;
            
            const endpoint = isStock ? '/api/trade' : '/api/indexfunds/trade';
            
            try {
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        symbol: symbol,
                        shares: parseFloat(shares),
                        action: 'buy'
                    })
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    alert(\`‚úì Successfully bought \${shares} shares of \${symbol}!\`);
                    updateAccount(); // Refresh the display
                } else {
                    alert(\`‚úó Error: \${result.error || 'Trade failed'}\`);
                }
            } catch (error) {
                alert(\`‚úó Error: \${error.message}\`);
            }
        }
        
        async function quickSell(symbol, maxShares, isStock) {
            const shares = prompt(\`How many shares of \${symbol} would you like to sell? (You own \${maxShares.toFixed(2)})\`, maxShares.toFixed(2));
            if (!shares || parseFloat(shares) <= 0) return;
            
            if (parseFloat(shares) > maxShares) {
                alert(\`You only own \${maxShares.toFixed(2)} shares of \${symbol}\`);
                return;
            }
            
            const endpoint = isStock ? '/api/trade' : '/api/indexfunds/trade';
            
            try {
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        symbol: symbol,
                        shares: parseFloat(shares),
                        action: 'sell'
                    })
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    alert(\`‚úì Successfully sold \${shares} shares of \${symbol}!\`);
                    updateAccount(); // Refresh the display
                } else {
                    alert(\`‚úó Error: \${result.error || 'Trade failed'}\`);
                }
            } catch (error) {
                alert(\`‚úó Error: \${error.message}\`);
            }
        }
        
        // Sell all positions
        async function sellAllPositions() {
            if (!confirm('Are you sure you want to sell ALL positions? This action cannot be undone.')) {
                return;
            }
            
            const accountRes = await fetch('/api/account');
            const account = await accountRes.json();
            
            let successCount = 0;
            let failCount = 0;
            
            // Sell all stocks
            for (const [symbol, shares] of Object.entries(account.portfolio)) {
                if (shares > 0) {
                    try {
                        const response = await fetch('/api/trade', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                symbol: symbol,
                                shares: shares,
                                action: 'sell'
                            })
                        });
                        
                        if (response.ok) {
                            successCount++;
                        } else {
                            failCount++;
                        }
                    } catch (error) {
                        failCount++;
                    }
                }
            }
            
            // Sell all index funds
            if (account.indexFundHoldings) {
                for (const [symbol, holding] of Object.entries(account.indexFundHoldings)) {
                    if (holding.shares > 0) {
                        try {
                            const response = await fetch('/api/indexfunds/trade', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    symbol: symbol,
                                    shares: holding.shares,
                                    action: 'sell'
                                })
                            });
                            
                            if (response.ok) {
                                successCount++;
                            } else {
                                failCount++;
                            }
                        } catch (error) {
                            failCount++;
                        }
                    }
                }
            }
            
            if (successCount > 0) {
                alert(\`‚úì Sold \${successCount} position(s).\${failCount > 0 ? ' Failed to sell ' + failCount + ' position(s).' : ''}\`);
            } else {
                alert('‚úó Failed to sell positions.');
            }
            
            updateAccount();
        }
        
        // Sell to zero gains (sell losing positions)
        async function sellToZeroGains() {
            if (!confirm('This will sell all positions with losses (negative gain/loss). Continue?')) {
                return;
            }
            
            const accountRes = await fetch('/api/account');
            const account = await accountRes.json();
            
            const stocksRes = await fetch('/api/stocks');
            const stocks = await stocksRes.json();
            
            const indexFundsRes = await fetch('/api/indexfunds');
            const indexFunds = await indexFundsRes.json();
            
            let successCount = 0;
            let failCount = 0;
            
            // Check stock positions
            for (const [symbol, shares] of Object.entries(account.portfolio)) {
                if (shares <= 0) continue;
                
                const stock = stocks.find(s => s.symbol === symbol);
                if (!stock) continue;
                
                const currentPrice = stock.price;
                const totalValue = shares * currentPrice;
                
                // Calculate cost
                let positionCost = 0;
                if (account.purchaseHistory && account.purchaseHistory[symbol]) {
                    let totalShares = 0;
                    let totalPaid = 0;
                    account.purchaseHistory[symbol].forEach(purchase => {
                        totalShares += purchase.shares;
                        totalPaid += purchase.shares * purchase.pricePerShare;
                    });
                    if (totalShares > 0) {
                        const avgCost = totalPaid / totalShares;
                        positionCost = shares * avgCost;
                    }
                }
                
                const gainLoss = totalValue - positionCost;
                
                // Sell if at a loss
                if (gainLoss < 0) {
                    try {
                        const response = await fetch('/api/trade', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                symbol: symbol,
                                shares: shares,
                                action: 'sell'
                            })
                        });
                        
                        if (response.ok) {
                            successCount++;
                        } else {
                            failCount++;
                        }
                    } catch (error) {
                        failCount++;
                    }
                }
            }
            
            // Check index fund positions
            if (account.indexFundHoldings) {
                for (const [symbol, holding] of Object.entries(account.indexFundHoldings)) {
                    if (holding.shares <= 0) continue;
                    
                    const fund = indexFunds.find(f => f.symbol === symbol);
                    if (!fund) continue;
                    
                    const currentPrice = fund.price;
                    const totalValue = holding.shares * currentPrice;
                    
                    // Calculate cost
                    let positionCost = 0;
                    if (holding.purchaseHistory && holding.purchaseHistory.length > 0) {
                        let totalShares = 0;
                        let totalPaid = 0;
                        holding.purchaseHistory.forEach(purchase => {
                            totalShares += purchase.shares;
                            totalPaid += purchase.shares * purchase.pricePerShare;
                        });
                        if (totalShares > 0) {
                            const avgCost = totalPaid / totalShares;
                            positionCost = holding.shares * avgCost;
                        }
                    }
                    
                    const gainLoss = totalValue - positionCost;
                    
                    // Sell if at a loss
                    if (gainLoss < 0) {
                        try {
                            const response = await fetch('/api/indexfunds/trade', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    symbol: symbol,
                                    shares: holding.shares,
                                    action: 'sell'
                                })
                            });
                            
                            if (response.ok) {
                                successCount++;
                            } else {
                                failCount++;
                            }
                        } catch (error) {
                            failCount++;
                        }
                    }
                }
            }
            
            if (successCount > 0) {
                alert(\`‚úì Sold \${successCount} losing position(s).\${failCount > 0 ? ' Failed to sell ' + failCount + ' position(s).' : ''}\`);
            } else {
                alert('No losing positions to sell.');
            }
            
            updateAccount();
        }
        
        // Sell shares from profitable positions until total profit is approximately 0
        async function sellToZeroProfit() {
            if (!confirm('This will sell shares from profitable positions until your total gain/loss is approximately zero. Continue?')) {
                return;
            }
            
            const accountRes = await fetch('/api/account');
            const account = await accountRes.json();
            
            const stocksRes = await fetch('/api/stocks');
            const stocks = await stocksRes.json();
            
            const indexFundsRes = await fetch('/api/indexfunds');
            const indexFunds = await indexFundsRes.json();
            
            // Calculate current total profit
            let positions = [];
            
            // Process stock positions
            for (const [symbol, shares] of Object.entries(account.portfolio)) {
                if (shares <= 0) continue;
                
                const stock = stocks.find(s => s.symbol === symbol);
                if (!stock) continue;
                
                const currentPrice = stock.price;
                const totalValue = shares * currentPrice;
                
                // Calculate cost
                let positionCost = 0;
                if (account.purchaseHistory && account.purchaseHistory[symbol]) {
                    let totalShares = 0;
                    let totalPaid = 0;
                    account.purchaseHistory[symbol].forEach(purchase => {
                        totalShares += purchase.shares;
                        totalPaid += purchase.shares * purchase.pricePerShare;
                    });
                    if (totalShares > 0) {
                        positionCost = (totalPaid / totalShares) * shares;
                    }
                }
                
                const gainLoss = totalValue - positionCost;
                
                if (gainLoss > 0) {
                    positions.push({
                        symbol,
                        isStock: true,
                        shares,
                        currentPrice,
                        avgCost: positionCost / shares,
                        gainLoss,
                        totalValue
                    });
                }
            }
            
            // Process index fund positions
            if (account.indexFundHoldings) {
                for (const [symbol, holding] of Object.entries(account.indexFundHoldings)) {
                    if (holding.shares <= 0) continue;
                    
                    const fund = indexFunds.find(f => f.symbol === symbol);
                    if (!fund) continue;
                    
                    const currentPrice = fund.price;
                    const totalValue = holding.shares * currentPrice;
                    
                    // Calculate cost
                    let positionCost = 0;
                    if (holding.purchaseHistory && holding.purchaseHistory.length > 0) {
                        let totalShares = 0;
                        let totalPaid = 0;
                        holding.purchaseHistory.forEach(purchase => {
                            totalShares += purchase.shares;
                            totalPaid += purchase.shares * purchase.pricePerShare;
                        });
                        if (totalShares > 0) {
                            positionCost = (totalPaid / totalShares) * holding.shares;
                        }
                    }
                    
                    const gainLoss = totalValue - positionCost;
                    
                    if (gainLoss > 0) {
                        positions.push({
                            symbol,
                            isStock: false,
                            shares: holding.shares,
                            currentPrice,
                            avgCost: positionCost / holding.shares,
                            gainLoss,
                            totalValue
                        });
                    }
                }
            }
            
            if (positions.length === 0) {
                alert('No profitable positions to sell.');
                return;
            }
            
            // Sort by profit percentage (sell highest profit % first)
            positions.sort((a, b) => {
                const aProfitPct = (a.gainLoss / (a.avgCost * a.shares)) * 100;
                const bProfitPct = (b.gainLoss / (b.avgCost * b.shares)) * 100;
                return bProfitPct - aProfitPct;
            });
            
            // Calculate total current profit
            const totalCurrentProfit = positions.reduce((sum, p) => sum + p.gainLoss, 0);
            
            let targetProfit = totalCurrentProfit; // Amount we need to reduce
            let successCount = 0;
            let failCount = 0;
            let profitReduced = 0;
            
            for (const pos of positions) {
                if (profitReduced >= targetProfit * 0.95) break; // Stop when we're within 5% of target
                
                // Calculate how many shares to sell to reach zero profit
                const profitPerShare = pos.currentPrice - pos.avgCost;
                let sharesToSell;
                
                if (profitReduced + pos.gainLoss <= targetProfit) {
                    // Sell entire position
                    sharesToSell = pos.shares;
                } else {
                    // Sell partial position
                    const remainingProfitToReduce = targetProfit - profitReduced;
                    sharesToSell = Math.min(pos.shares, Math.ceil(remainingProfitToReduce / profitPerShare));
                }
                
                try {
                    const endpoint = pos.isStock ? '/api/trade' : '/api/indexfunds/trade';
                    const response = await fetch(endpoint, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            symbol: pos.symbol,
                            shares: sharesToSell,
                            action: 'sell'
                        })
                    });
                    
                    if (response.ok) {
                        successCount++;
                        profitReduced += sharesToSell * profitPerShare;
                    } else {
                        failCount++;
                    }
                } catch (error) {
                    failCount++;
                }
            }
            
            if (successCount > 0) {
                alert(\`‚úì Sold shares from \${successCount} position(s) to reduce profit by $\${profitReduced.toFixed(2)}.\${failCount > 0 ? ' Failed to sell from ' + failCount + ' position(s).' : ''}\`);
            } else {
                alert('‚úó Failed to sell positions.');
            }
            
            updateAccount();
        }
        
        // Toggle selection of all positions
        function toggleAllPositions() {
            const selectAll = document.getElementById('selectAllPositions');
            const checkboxes = document.querySelectorAll('.position-checkbox');
            checkboxes.forEach(cb => cb.checked = selectAll.checked);
        }
        
        // Sell selected positions
        async function sellSelectedPositions() {
            const selectedCheckboxes = Array.from(document.querySelectorAll('.position-checkbox:checked'));
            
            if (selectedCheckboxes.length === 0) {
                alert('Please select at least one position to sell.');
                return;
            }
            
            if (!confirm(\`Are you sure you want to sell \${selectedCheckboxes.length} selected position(s)?\`)) {
                return;
            }
            
            let successCount = 0;
            let failCount = 0;
            
            for (const checkbox of selectedCheckboxes) {
                const symbol = checkbox.dataset.symbol;
                const shares = parseFloat(checkbox.dataset.shares);
                const isStock = checkbox.dataset.isstock === 'true';
                
                try {
                    const endpoint = isStock ? '/api/trade' : '/api/indexfunds/trade';
                    const response = await fetch(endpoint, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            symbol: symbol,
                            shares: shares,
                            action: 'sell'
                        })
                    });
                    
                    if (response.ok) {
                        successCount++;
                    } else {
                        failCount++;
                    }
                } catch (error) {
                    failCount++;
                }
            }
            
            if (successCount > 0) {
                alert(\`‚úì Sold \${successCount} position(s).\${failCount > 0 ? ' Failed to sell ' + failCount + ' position(s).' : ''}\`);
            } else {
                alert('‚úó Failed to sell positions.');
            }
            
            // Uncheck the select all checkbox
            document.getElementById('selectAllPositions').checked = false;
            
            updateAccount();
        }
        
        // Cover a single short position
        async function coverShort(symbol, shares) {
            if (!confirm(\`Cover \${shares} shares of \${symbol}?\`)) {
                return;
            }
            
            try {
                const response = await fetch('/api/trade', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        symbol: symbol,
                        shares: shares,
                        action: 'cover'
                    })
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    alert(\`‚úì Successfully covered \${shares} shares of \${symbol}!\`);
                    updateAccount();
                } else {
                    alert(\`‚úó Error: \${result.error || 'Cover failed'}\`);
                }
            } catch (error) {
                alert(\`‚úó Error: \${error.message}\`);
            }
        }
        
        // Cover all short positions
        async function coverAllShorts() {
            if (!confirm('Are you sure you want to cover ALL short positions?')) {
                return;
            }
            
            const accountRes = await fetch('/api/account');
            const account = await accountRes.json();
            
            if (!account.shortPositions || Object.keys(account.shortPositions).length === 0) {
                alert('No short positions to cover.');
                return;
            }
            
            let successCount = 0;
            let failCount = 0;
            
            for (const [symbol, position] of Object.entries(account.shortPositions)) {
                if (position.shares > 0) {
                    try {
                        const response = await fetch('/api/trade', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                symbol: symbol,
                                shares: position.shares,
                                action: 'cover'
                            })
                        });
                        
                        if (response.ok) {
                            successCount++;
                        } else {
                            failCount++;
                        }
                    } catch (error) {
                        failCount++;
                    }
                }
            }
            
            if (successCount > 0) {
                alert(\`‚úì Covered \${successCount} short position(s).\${failCount > 0 ? ' Failed to cover ' + failCount + ' position(s).' : ''}\`);
            } else {
                alert('‚úó Failed to cover short positions.');
            }
            
            updateAccount();
        }
        
        updateAccount();
        setInterval(updateAccount, 2000);
    </script>
    <script>
        // Apply era theme based on game time
        async function updateEraTheme() {
            const response = await fetch('/api/time');
            const data = await response.json();
            const gameDate = new Date(data.currentTime);
            const year = gameDate.getFullYear();
            applyEraTheme(year);
        }
        
        updateEraTheme();
        setInterval(updateEraTheme, 10000);
    </script>
    `
}) %>
